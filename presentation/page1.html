<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DUST: A New Reality</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #000000;
            color: #E2E8F0;
        }
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            text-align: center;
            pointer-events: none;
            padding: 4rem 2rem;
        }
        .title-container {
            width: 100%;
            pointer-events: none;
        }
        .text-container {
            max-width: 900px;
            padding: 2.5rem;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0;
            transform: translateY(30px);
        }
        h1.main-title {
            font-size: 3rem;
            line-height: 1.1;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
            color: #FBBF24;
        }
         h2.subtitle {
            font-size: 2rem;
            line-height: 1.2;
            font-weight: 700;
            color: #E2E8F0;
        }
        p {
            font-size: 1.2rem;
            color: #A1A1AA;
            margin-top: 1.5rem;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div class="overlay">
        <div class="title-container">
            <h1 class="text-4xl md:text-5xl font-black text-slate-300">A New Physical Principle</h1>
        </div>
        <div id="text-container" class="text-container">
            <h2 class="subtitle">Is everything is a question of geometry and Duality?</h2>
            <p>The Ducci Unified Spectral Theory (DUST): proposes that the paradoxes of modern physics are symptoms of a missing foundation. We present a new framework where the wave-particle nature of reality is a controllable state, and the constants of the Standard Model emerge as necessary consequences of a single, underlying geometric blueprint of the vacuum.</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Scene Setup ---
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            const container = document.getElementById('canvas-container');
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            camera.position.z = 25;

            // --- Lighting ---
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const pointLight = new THREE.PointLight(0xFBBF24, 1.5, 80);
            scene.add(pointLight);

            // --- Prime Periodic Lattice ---
            const latticeGroup = new THREE.Group();
            const nodeMaterial = new THREE.MeshBasicMaterial({ color: 0x334155, transparent: true, opacity: 0.25 });
            const nodeGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const gridSize = 14;
            const spacing = 5;

            for (let x = -gridSize; x <= gridSize; x++) {
            for (let y = -gridSize; y <= gridSize; y++) {
            for (let z = -gridSize; z <= gridSize; z++) {
                const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                node.position.set(x * spacing, y * spacing, z * spacing);
                latticeGroup.add(node);
            }}}
            scene.add(latticeGroup);

            // --- Central Spectral Particle ---
            const particleGroup = new THREE.Group();
            scene.add(particleGroup);
            
            const coreMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 1.5,
                metalness: 0.9,
                roughness: 0.1
            });
            const core = new THREE.Mesh(new THREE.SphereGeometry(1.2, 128, 128), coreMat);
            particleGroup.add(core);

            const shellGeo = new THREE.SphereGeometry(4.5, 128, 128);
            const shellMat = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0.0 } },
                vertexShader: `
                    uniform float time;
                    varying float noise;
                    // Classic Perlin 3D noise
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                    float snoise(vec3 v) {
                        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                        vec3 i  = floor(v + dot(v, C.yyy));
                        vec3 x0 = v - i + dot(i, C.xxx);
                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min( g.xyz, l.zxy );
                        vec3 i2 = max( g.xyz, l.zxy );
                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy; // -0.5 = 1.0 - 1.5
                        vec3 x3 = x0 - D.yyy;
                        i = mod289(i);
                        vec4 p = permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 );
                        float n_ = 0.142857142857; // 1.0/7.0
                        vec3  ns = n_ * D.wyz - D.xzx;
                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_);
                        vec4 x = x_ *ns.x + ns.yyyy;
                        vec4 y = y_ *ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);
                        vec4 b0 = vec4( x.xy, y.xy );
                        vec4 b1 = vec4( x.zw, y.zw );
                        vec4 s0 = floor(b0)*2.0 + 1.0;
                        vec4 s1 = floor(b1)*2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));
                        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                        vec3 p0 = vec3(a0.xy,h.x);
                        vec3 p1 = vec3(a0.zw,h.y);
                        vec3 p2 = vec3(a1.xy,h.z);
                        vec3 p3 = vec3(a1.zw,h.w);
                        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                        p0 *= norm.x;
                        p1 *= norm.y;
                        p2 *= norm.z;
                        p3 *= norm.w;
                        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                        m = m * m;
                        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
                    }
                    void main() {
                        vec3 animatedNormal = normalize(position);
                        noise = snoise(animatedNormal * 2.5 + time * 0.4);
                        vec3 displaced = position + animatedNormal * noise * 2.0; // Increased displacement
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
                    }
                `,
                fragmentShader: `
                    varying float noise;
                    void main() {
                        float intensity = pow(0.7 - abs(noise), 2.5); // Sharper contrast
                        gl_FragColor = vec4(0.98, 0.75, 0.25, intensity * 0.9); // More opaque
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            const shell = new THREE.Mesh(shellGeo, shellMat);
            particleGroup.add(shell);

            // --- GSAP Animation ---
            gsap.fromTo(camera.position, { z: 150, y: 30 }, { z: 25, y: 0, duration: 12, ease: "power3.inOut" });
            gsap.from(".title-container", {opacity: 0, duration: 2, delay: 2});
            gsap.to("#text-container", { opacity: 1, y: 0, duration: 2.5, ease: "power2.out", delay: 5 });
            
            // --- Render Loop ---
            const clock = new THREE.Clock();
            function animate() {
                requestAnimationFrame(animate);
                const elapsedTime = clock.getElapsedTime();
                
                shell.material.uniforms.time.value = elapsedTime;
                particleGroup.rotation.y += 0.001;
                particleGroup.rotation.x += 0.0005;
                
                latticeGroup.rotation.y -= 0.0002;
                latticeGroup.rotation.x -= 0.0001;

                pointLight.position.x = Math.sin(elapsedTime * 0.5) * 15;
                pointLight.position.y = Math.cos(elapsedTime * 0.3) * 15;
                pointLight.position.z = Math.cos(elapsedTime * 0.7) * 15;
                
                renderer.render(scene, camera);
            }
            animate();

            // --- Handle Resize ---
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }, false);
        });
    </script>
</body>
</html>
