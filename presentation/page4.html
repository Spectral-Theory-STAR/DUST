<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DUST: The Duccion</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #000000; /* Pure black background */
            margin: 0;
            cursor: grab;
        }
        body:active {
            cursor: grabbing;
        }
        .text-overlay {
            position: fixed;
            top: 20%; /* Moved text higher up */
            left: 50%;
            transform: translate(-50%, -50%);
            color: #E2E8F0;
            text-align: center;
            width: 90%;
            max-width: 1200px;
            pointer-events: none;
            z-index: 20;
        }
        .text-overlay h1 {
            font-size: 4rem;
            font-weight: 900;
            text-shadow: 0 0 25px rgba(251, 191, 36, 0.5), 0 0 10px rgba(255, 255, 255, 0.3);
            color: #FBBF24; /* Amber */
            letter-spacing: -0.025em;
        }
        .text-overlay h2 {
            font-size: 1.5rem;
            margin-top: 1.5rem;
            color: #94A3B8;
            font-weight: 300;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #tooltip {
            position: absolute;
            display: none;
            padding: 10px 16px;
            background-color: rgba(17, 24, 39, 0.9);
            backdrop-filter: blur(8px);
            border: 1px solid #FBBF24;
            color: #FDE68A;
            border-radius: 8px;
            pointer-events: none;
            font-size: 1rem;
            white-space: pre;
            z-index: 50;
            text-align: left;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.15);
        }
        .acronym {
             margin-top: 2rem;
             display: inline-block;
             font-size: 1.25rem;
             font-weight: 700;
             color: #475569;
             letter-spacing: 0.2em;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in { animation: fadeIn 2s ease-out forwards; }
    </style>
</head>
<body>

    <div id="canvas-container" class="absolute top-0 left-0 w-full h-full"></div>
    <div id="tooltip"></div>
    
    <div class="text-overlay">
        <div style="animation-delay: 0.5s;" class="fade-in">
            <h1 id="main-headline">The Duccion.</h1>
            <div class="acronym">
                <span>D</span>UALITY'S <span>U</span>NIFIED <span>C</span>OHERENT <span>C</span>ONSTRUCT <span>ION</span>
            </div>
        </div>
        <div style="animation-delay: 1.2s;" class="fade-in">
            <h2 id="sub-headline">The single, fundamental particle from which all of reality is assembled.</h2>
        </div>
    </div>

    <script>
        // --- Basic Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        const container = document.getElementById('canvas-container');
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        camera.position.z = 5;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 2, 100);
        pointLight.position.set(0, 0, 3);
        scene.add(pointLight);
        const blueLight = new THREE.PointLight(0x00aaff, 3, 50);
        scene.add(blueLight);

        // --- The Duccion Model ---
        const duccionGroup = new THREE.Group();
        scene.add(duccionGroup);

        // Core
        const coreGeometry = new THREE.IcosahedronGeometry(0.5, 5);
        const coreMaterial = new THREE.MeshStandardMaterial({
            color: 0xFBBF24,
            emissive: 0x92400E,
            metalness: 0.9,
            roughness: 0.1,
            envMapIntensity: 0.8
        });
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        duccionGroup.add(core);

        // Energy Trails
        const trailCount = 5;
        for (let i = 0; i < trailCount; i++) {
            const curvePoints = [];
            for(let j = 0; j < 60; j++) {
                const angle = (j / 59) * Math.PI * 4;
                const radius = 1.1 + Math.sin(angle * (i + 2)) * 0.3;
                curvePoints.push(new THREE.Vector3(
                    Math.cos(angle) * radius,
                    Math.sin(angle * 2.5 + i) * 0.5,
                    Math.sin(angle) * radius
                ));
            }
            const curve = new THREE.CatmullRomCurve3(curvePoints);
            const tubeGeometry = new THREE.TubeGeometry(curve, 128, 0.015, 8, false);
            const tubeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x38BDF8, 
                transparent: true, 
                opacity: 0.5,
                blending: THREE.AdditiveBlending 
            });
            const trail = new THREE.Mesh(tubeGeometry, tubeMaterial);
            trail.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            duccionGroup.add(trail);
        }

        // --- Particle Nebula ---
        const nebulaGeometry = new THREE.BufferGeometry();
        const nebulaVertices = [];
        for (let i = 0; i < 5000; i++) {
            const x = (Math.random() - 0.5) * 8;
            const y = (Math.random() - 0.5) * 8;
            const z = (Math.random() - 0.5) * 8;
            nebulaVertices.push(x, y, z);
        }
        nebulaGeometry.setAttribute('position', new THREE.Float32BufferAttribute(nebulaVertices, 3));
        const nebulaMaterial = new THREE.PointsMaterial({ color: 0x38BDF8, size: 0.01, transparent: true, opacity: 0.3 });
        const nebula = new THREE.Points(nebulaGeometry, nebulaMaterial);
        scene.add(nebula);


        // --- Prime Periodic Lattice Background ---
        const latticeGroup = new THREE.Group();
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x1E293B, transparent: true, opacity: 0.1 });
        const gridSize = 40;
        const gridSpacing = 2;
        for (let i = -gridSize; i <= gridSize; i += gridSpacing) {
            const pointsX = [new THREE.Vector3(-gridSize, i, -gridSize), new THREE.Vector3(gridSize, i, -gridSize)];
            const pointsY = [new THREE.Vector3(i, -gridSize, -gridSize), new THREE.Vector3(i, gridSize, -gridSize)];
            const geometryX = new THREE.BufferGeometry().setFromPoints(pointsX);
            const geometryY = new THREE.BufferGeometry().setFromPoints(pointsY);
            latticeGroup.add(new THREE.Line(geometryX, lineMaterial));
            latticeGroup.add(new THREE.Line(geometryY, lineMaterial));
        }
        latticeGroup.position.z = -15;
        scene.add(latticeGroup);

        // --- Interactivity (Hotspots) ---
        const hotspots = [];
        const tooltip = document.getElementById('tooltip');
        const hotspotData = [
            { position: new THREE.Vector3(0, 0.7, 0), text: "<b>Charge:</b> &plusmn;1/3 e<br>The fundamental quantum of charge." },
            { position: new THREE.Vector3(0.7, 0, 0), text: "<b>Spin:</b> 1/2<br>A fundamental fermion, the building block of matter." },
            { position: new THREE.Vector3(-0.7, -0.2, 0), text: "<b>Mass:</b> ~0.168 MeV/c&sup2;<br>The true, indivisible unit of mass." }
        ];

        hotspotData.forEach(data => {
            const hotspotGeometry = new THREE.SphereGeometry(0.05, 16, 16);
            const hotspotMaterial = new THREE.MeshBasicMaterial({ color: 0x67E8F9, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
            const hotspot = new THREE.Mesh(hotspotGeometry, hotspotMaterial);
            hotspot.position.copy(data.position);
            hotspot.userData.text = data.text;
            duccionGroup.add(hotspot);
            hotspots.push(hotspot);
        });

        // --- Mouse Controls & Raycasting ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function onMouseMove(event) {
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;
            if (isDragging) {
                duccionGroup.rotation.y += deltaX * 0.005;
                duccionGroup.rotation.x += deltaY * 0.005;
            }
            previousMousePosition = { x: event.clientX, y: event.clientY };
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        
        document.addEventListener('mousedown', () => { isDragging = true; });
        document.addEventListener('mouseup', () => { isDragging = false; });
        document.addEventListener('mousemove', onMouseMove);

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();

            core.rotation.y += 0.002;
            core.rotation.x += 0.001;
            duccionGroup.scale.setScalar(1 + Math.sin(elapsedTime * 0.5) * 0.05);

            nebula.rotation.y += 0.0002;
            latticeGroup.rotation.z += 0.0001;

            blueLight.position.x = Math.sin(elapsedTime * 0.7) * 4;
            blueLight.position.y = Math.cos(elapsedTime * 0.5) * 4;
            blueLight.position.z = Math.cos(elapsedTime * 0.3) * 4;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(hotspots);

            if (intersects.length > 0) {
                const hotspot = intersects[0].object;
                tooltip.style.display = 'block';
                tooltip.innerHTML = hotspot.userData.text;
                const vector = new THREE.Vector3().copy(hotspot.position);
                duccionGroup.localToWorld(vector);
                vector.project(camera);
                tooltip.style.left = `${(vector.x + 1) / 2 * window.innerWidth + 20}px`;
                tooltip.style.top = `${-(vector.y - 1) / 2 * window.innerHeight + 20}px`;
            } else {
                tooltip.style.display = 'none';
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);
    </script>
</body>
</html>
